<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>自己写的</title>
  </head>

  <body>
    <div id="app">
      <h1 class="title"></h1>
    </div>
  </body>

  <!-- <script src="https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js"></script> -->
  <!-- <script src="https://unpkg.com/vue@3"></script> -->
  <script src="./reactivity/reactive.js"></script>
  <script src="dev/rendererDev.js"></script>

  <script>
    // const text = ref('小明') //ref在定义完毕时就已经时响应式,收集依赖发生在读取.value时
    // const comment = ref('注释')
    /** const commentNode = {
     *   type: Comment,
     *   children: comment.value // 这一步就进行了get,就会收集依赖,,但是没有在effect里面,所以无法收集依赖,所以commentNode的创建要在effect里面,
     * }
     * const textNode = {
     *   type: Text,
     *   children: text.value, // 这一步就进行了get操作,就会收集依赖,但是没有在effect里面,所以无法收集依赖,所以textNode的创建要在effect里面,
     * }
     */
    /* 普通原生html节点 */
    // effect(async () => {
    //   // const commentNode = {
    //   //   type: Comment,
    //   //   children:
    //   //     comment.value /* 这一步就进行了get,就会收集依赖,所以commentNode的创建要在effect里面 */,
    //   // }
    //   // const textNode = {
    //   //   type: Text,
    //   //   children: text.value /* 这一步就进行了get,就会收集依赖,所以textNode的创建要在effect里面 */,
    //   // }
    //   // const fragmentNode = {
    //   //   type: Fragment,
    //   //   children: [textNode, commentNode],
    //   // }
    //   /**
    //    * 如果把textNode和commentNode的创建移到effect外面,
    //    * 那在effect中
    //    * textNode读取children时其实是原始值"小明",
    //    * commentNode读取children时也是原始值"注释",
    //    * 这是因为在创建时就已经完成了读取操作,并将text.value和comment.value的值读取进children中,
    //    * 并且完成了依赖收集,所以在node.children里的数据其实是:
    //    * { type: Text, children: "小明" }
    //    * { type: Comment, children: "注释" }
    //    * 所以我们要在effect里读取响应式数据，而不是直接将获取到的响应式数据给到某一个值以期望可以与副作用函数建立联系，这样是不行的
    //    */

    //   /* patch时,会进入子节点,然后对子节点patch完了才会退出到父节点 */
    //   const oldeNode = {
    //     type: 'div',
    //     children: [
    //       { type: 'p', children: '1', key: 1 },
    //       { type: 'p', children: '2', key: 2 },
    //       { type: 'p', children: '3', key: 3 },
    //       { type: 'p', children: 'xygod', key: 4 },
    //       { type: 'p', children: '6', key: 6 },
    //       { type: 'p', children: '5', key: 5 },
    //     ],
    //   }
    //   const newNode = {
    //     type: 'div',
    //     children: [
    //       { type: 'p', children: '1', key: 1 },
    //       { type: 'p', children: '3', key: 3 },
    //       { type: 'p', children: 'xygodcyx', key: 4 },
    //       { type: 'p', children: '2', key: 2 },
    //       { type: 'p', children: '7', key: 7 },
    //       { type: 'p', children: '5', key: 5 },
    //     ],
    //   }
    //   // render(node1, document.querySelector('#app'))
    //   // render(node1, document.querySelector('#app')) // 2s后会先更新,然后更新
    //   render(oldeNode, document.querySelector('#app')) // 1s后立即触发更新,把node1覆盖,然后2s后重复这个操作
    //   await new Promise((re) => {
    //     setTimeout(re, 1000)
    //   })
    //   render(newNode, document.querySelector('#app')) // 1s后立即触发更新,把node1覆盖,然后2s后重复这个操作
    // })
    // setTimeout(() => {
    //   // text.value = '小红'
    //   // comment.value = '注释2'
    // }, 1000)

    // const text = ref('xygod')

    const myComponent1 = {
      name: 'component',
      data() {
        return {
          text: 'xygod',
          a: 1,
          b: 2,
        }
      },
      props: {
        title: {
          type: String,
          default: '默认值',
        },
      },
      mounted() {
        // this.autoRun()
      },
      methods: {
        autoRun() {
          console.log(this.title)
        },
        updateText() {
          this.text += Math.random().toFixed(1).toString()
        },
      },
      computed: {
        sum() {
          return this.a + this.b
        },
        allTitle() {
          return this.title + ' ' + '标题'
        },
      },
      watch: {
        text(n) {
          this.$emit('updateText', n)
        },
        sum(n, o) {
          // console.log(n, o)
        },
        a(n, o) {
          // console.log(n, o)
        },
      },
      render(state) {
        return {
          type: 'div',
          props: {
            id: 'hello',
          },
          children: [
            {
              type: 'button',
              props: {
                onClick: () => {
                  this.a++
                  this.updateText()
                },
              },
              children: 'a++',
            },
            {
              type: Text,
              children: `hello,my name is ${this.allTitle.value},sum:${this.sum.value},text:${this.text}`,
            },
          ],
        }
      },
    }
    const componentVNode1 = {
      type: myComponent1,
      props: {
        title: 'xygod',
        other: 'other',
        onUpdateText(data) {},
      },
      children: {
        // 插槽
      },
    }

    const myComponent2 = {
      name: 'component',
      data() {
        return {
          text: text.value,
          a: 1,
          b: 2,
        }
      },
      props: {
        title: String,
      },
      mounted() {
        this.autoRun()
        console.log(this.sum.value)
        console.log(this.allTitle.value)
      },
      methods: {
        autoRun() {
          console.log(this.title)
        },
      },
      computed: {
        sum() {
          return this.a + this.b
        },
        allTitle() {
          return this.title + ' ' + '标题2'
        },
      },
      render(state) {
        return {
          type: 'div',
          props: {
            id: 'hello',
          },
          children: `hello,my name is ${this.allTitle.value}`,
        }
      },
    }

    const componentVNode2 = {
      type: myComponent2,
      props: {
        title: 'A Small Title',
        other: 'other',
      },
    }

    const myComponentSetup = {
      name: 'componentSetUp',
      props: {
        title: String,
      },
      setup(props, { emit, attrs }) {
        const a = ref(1)
        const b = ref(2)
        const sum = computed(() => a.value + b.value)
        const obj = reactive({ a: 1, b: 2 })
        watch(sum, (n, o) =>
          emit('sumUpdate', sum.value, 'update')
        ) /* 可以正常使用watch结合computed */
        return () => {
          return {
            type: 'div',
            props: {
              class: 'green',
            },
            children: [
              {
                type: 'button',
                props: {
                  onClick() {
                    a.value++
                    attrs.other = Math.random().toFixed(2)
                  },
                },
                children: `a++`,
                key: 1,
              },
              h(
                'span',
                2,
                {
                  onClick() {
                    console.log(1)
                  },
                },
                `hello,my name is ${props.title},sum:${sum.value},attrs:${attrs.other}`
              ),
            ],
          }
        }
      },
    }
    const componentVNodeSetup = {
      type: myComponentSetup,
      props: {
        title: 'xygod',
        other: 'other',
        onSumUpdate(...payload) {
          console.log('onSumUpdate', ...payload)
        },
      },
      children: {
        // 插槽,组件的子节点就是插槽
      },
    }
    render(componentVNodeSetup, document.querySelector('#app'))
    // render(componentVNode1, document.querySelector('#app'))
    // render(componentVNode2, document.querySelector('#app'))
  </script>
</html>
